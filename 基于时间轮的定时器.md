# 定时器

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
高性能开发之定时器讲解，据我所知常见的定时器无非三种，基于排序链表、最小堆、时间轮，
基于最小堆的定时器可用于定时器数量不多的场景中，但是基于时间轮的更加高效，基于时间轮的定时器实现，
为了支持大范围的时间，每个齿轮所维护的链表为有序链表，每次插入时先 mod 处 spoke，再从头遍历链表，
以便将定时器插入到合适位置，本质上还是基于排序链表的，时间复杂度未变

### 应用场景分析

客户端发起的请求，需要对每个请求做超时检查

方案一：一个定时器，一个 multimap<endtime, request> 用于保存请求超时列表，每次超时检查 multimap。这样
请求的插入时间复杂度为 O(logn)，遍历和删除的时间复杂度为 O(1)，且需要额外的编码

方案二：一个请求一个定时器，这样并不需要额外的开销来保存请求，也无需额外编码，等待超时处理即可(请求的信息作为参数
给定时器 node 保存)。时间复杂度为 0，如果程序中的定时器数量比较少，基于最小堆的时间轮一般就可以满足需求，且实现简单

### 三种定时器复杂度分析

|   实现方式   | startTimer | stopTimer | perTickBookKeeping |
| :----------: | :--------: | :-------: | :----------------: |
| 基于排序链表 |    O(n)    |   O(1)    |        O(1)        |
|  基于最小堆  |  O(logn)   |   O(1)    |        O(1)        |
|  基于时间轮  |    O(1)    |   O(1)    |        O(1)        |

### 实现分析

- 基于时间轮
  - 简单时间轮

每个齿轮保存一个超时的 node 链表，一个齿轮表示一个时间刻度，比如时钟里面的一小格代表一秒，
钟表的秒钟每次跳一格。假设一个刻度代表 10 ms，则 2^32 表示 10.9 分钟，当表示的时间范围增大时，空间复杂度也会增大

- 基于最小堆

用 C++ 中的 multimap 保存即可

- 基于排序链表

这两个实现均为简单，无话可说
